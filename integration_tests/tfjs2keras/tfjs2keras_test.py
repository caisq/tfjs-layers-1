# Copyright 2018 Google LLC
#
# Use of this source code is governed by an MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT.
# =============================================================================

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import json
import os
import shutil
import subprocess
import tempfile

import keras
import numpy as np
import tensorflow as tf
import tensorflowjs as tfjs


def _call_command(command):
  print('Calling in %s: %s' % (os.getcwd(), ' '.join(command)))
  subprocess.check_call(command)


def _generate_random_tensor_like(xs, integer_max=None):
  if isinstance(xs, list):
    return [_generate_random_tensor_like(x) for x in xs]
  else:
    if integer_max is None:
      return np.random.randn(*xs.shape).astype(xs.dtype)
    else:
      return np.random.randint(0, integer_max, xs.shape).astype(xs.dtype)


def _save_tensors_to_disk(tensors, path_prefix):
  '''Save a number of tensors to disk, as JSON files.

  Args:
    tensors: A list of numpy arrays to be saved.
    path_prefix: The prefix for the save target directory. For example,
      if `path_prefix` is `/tmp/a` and there are two numpy arrays in
      `tensors`, then the two resulting files will be
        `/tmp/a_1.json`, `/tmp/a_1.shape.json` for the 1st tensor
        and
        `/tmp/a_2.json`, `/tmp/a_2.shape.json` for the 2nd tensor.
  '''
  num_tensors = len(tensors)
  for i, tensor in enumerate(tensors):
    save_value_path = '%s_%d.json' % (path_prefix, i + 1)
    with open(save_value_path, 'wt') as f:
      json.dump(tensor.tolist(), f)
    save_shape_path = '%s_%d.shape.json' % (path_prefix, i + 1)
    with open(save_shape_path, 'wt') as f:
      json.dump(list(tensor.shape), f)


class Tfjs2KerasExportTest(tf.test.TestCase):

  @classmethod
  def setUpClass(cls):
    print('Preparing TensorFlow.js...')
    cls._tmp_dir = tempfile.mkdtemp()
    cwd = os.path.dirname(os.path.realpath(__file__))
    os.chdir(os.path.join(cwd, '..', '..'))
    _call_command(['yarn'])
    _call_command(['yarn', 'build'])
    _call_command(['yarn', 'link'])

    os.chdir(cwd)
    _call_command(['yarn'])
    _call_command(['yarn', 'link', '@tensorflow/tfjs-layers'])
    _call_command(['yarn', 'build'])
    _call_command(['node', 'dist/tfjs_save.js', cls._tmp_dir])

  @classmethod
  def tearDownClass(cls):
    shutil.rmtree(cls._tmp_dir)

  def _loadAndTestModel(self, model_path):
    """Load a Keras Model from artifacts generated by tensorflow.js.

    This method tests:
      - Python Keras loading of the topology JSON file saved from TensorFlow.js.
      - Python Keras loading of the model's weight values.
      - The equality of the `model.predict()` output between Python Keras and
        TensorFlow.js (up to a certain numeric tolerance.)
      - Constructs a new set of random input values of the same dtype and shape
        as the loaded ones, run `model.predict()` with them, and serialize the
        new input values, together with the output from `model.predict()` as
        JSON files.
      - Serialize the loaded model in the TensorFlow.js format using the
        converter module from tensorflowjs.
      - Call `tfjs_load.ts` with `node` to load the model, along with the
        serialized new input values in JavaScript and check the equality of the
        `model.predict()` output in JavaScript and that output serialized from
        Python.

    TODO(cais): In addition to testing `model.predict()`, test `model.fit()`.

    Args:
      model_path: Path to the model JSON file.
    """
    xs_shape_path = os.path.join(
        self._tmp_dir, model_path + '.xs-shapes.json')
    xs_dtype_path = os.path.join(
        self._tmp_dir, model_path + '.xs-dtypes.json')
    xs_data_path = os.path.join(
        self._tmp_dir, model_path + '.xs-data.json')
    with open(xs_shape_path, 'rt') as f:
      xs_shapes = json.load(f)
    with open(xs_dtype_path, 'rt') as f:
      xs_dtypes = json.load(f)
    with open(xs_data_path, 'rt') as f:
      xs_values = json.load(f)
    xs = [np.array(value, dtype=np.float32).reshape(shape)
          for value, shape in zip(xs_values, xs_shapes)]
    if len(xs) == 1:
      xs = xs[0]

    xs_input_integer_max_path = os.path.join(
        self._tmp_dir, model_path + '.xs-input-integer-max.json')
    xs_input_integer_max = None
    if os.path.isfile(xs_input_integer_max_path):
      with open(xs_input_integer_max_path, 'rt') as f:
        xs_input_integer_max = json.load(f)

    ys_shape_path = os.path.join(
        self._tmp_dir, model_path + '.ys-shapes.json')
    ys_dtype_path = os.path.join(
        self._tmp_dir, model_path + '.ys-dtypes.json')
    ys_data_path = os.path.join(
        self._tmp_dir, model_path + '.ys-data.json')
    with open(ys_shape_path, 'rt') as f:
      ys_shapes = json.load(f)
    with open(ys_dtype_path, 'rt') as f:
      ys_dtypes = json.load(f)
    with open(ys_data_path, 'rt') as f:
      ys_values = json.load(f)
    ys = [np.array(value, dtype=np.float32).reshape(shape)
          for value, shape in zip(ys_values, ys_shapes)]
    if len(ys) == 1:
      ys = ys[0]

    with tf.Graph().as_default(), tf.Session():
      model_json_path = os.path.join(self._tmp_dir, model_path, 'model.json')
      print('Loading model from path %s' % model_json_path)
      model = tfjs.converters.load_keras_model(model_json_path)
      ys_new = model.predict(xs)
      if isinstance(ys, list):
        self.assertEqual(len(ys), len(ys_new))
        for i, y in enumerate(ys):
          self.assertAllClose(y, ys_new[i])
      else:
        self.assertAllClose(ys, ys_new)

      new_xs = _generate_random_tensor_like(
          xs, integer_max=xs_input_integer_max)
      new_ys = model.predict(new_xs)
      new_save_path = os.path.join(self._tmp_dir, model_path, 'from_py')

      if not isinstance(new_xs, list):
        new_xs = [new_xs]
      if not isinstance(new_ys, list):
        new_ys = [new_ys]

      tfjs.converters.save_keras_model(model, new_save_path)

      _save_tensors_to_disk(new_xs, os.path.join(new_save_path, 'xs'))
      _save_tensors_to_disk(new_ys, os.path.join(new_save_path, 'ys'))

      _call_command(['node', 'dist/tfjs_load.js', new_save_path ])

  def testMLP(self):
    self._loadAndTestModel('mlp')

  def testCNN(self):
    self._loadAndTestModel('cnn')

  def testDepthwiseCNN(self):
    self._loadAndTestModel('depthwise_cnn')

  def testSimpleRNN(self):
    self._loadAndTestModel('simple_rnn')

  def testGRU(self):
    self._loadAndTestModel('gru')

  def testBidirectionalLSTM(self):
    self._loadAndTestModel('bidirectional_lstm')

  def testTimeDistributedLSTM(self):
    self._loadAndTestModel('time_distributed_lstm')

  def testOneDimensional(self):
    self._loadAndTestModel('one_dimensional')

  def testFunctionalMerge(self):
    self._loadAndTestModel('functional_merge.json')


if __name__ == '__main__':
  tf.test.main()
